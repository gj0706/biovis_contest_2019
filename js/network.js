let filePaths = ['data/testNode.tsv','data/test.tsv'];const width = 2000,      height = 2000;const format = d3.format(',d');const circleScale = 2.4;const pack = d3.pack()    .size([width,height])    .padding(1);let svgPack = d3.select('#chart')    .append('svg')    .attr('class','packChart')    .attr('width', width)    .attr('height', height);// Read filesPromise.all(filePaths.map(path=>d3.tsv(path))).then(files=>{    let nodeData = files[0];    let linkData = files[1];    let colors = nodeData.map(d=>{        return{            node: d['#node'],            color: d.color        }    });    console.log(colors);    let colorScale = d3.scaleOrdinal().range(colors).domain([0,10000]);    // console.log(colors);    let links = linkData.map(d=>d);    let linkNodes = d3.nest().key(d=>d.source).entries(linkData);    // console.log(linkNodes);    // let root = _.supergroup(nodeData,['tax_species','desc','#node']).asRootVal('All species');    // root.addRecordsAsChildrenToLeafNodes();    // let layout = d3.hierarchy(root);    // debugger    // let rollupData = d3.rollup(nodeData, v=>{    //         return {    //             length:v.length,    //             color: _.filter(colors, d=>d.node === v.key ? d.color:undefined)    //         }    //     }, d=>d['tax_species'],d=>d['desc'],d=>d['#node'] );    // console.log(rollupData);    let newData = makeHierarchy({        data:nodeData,        groupByFns:[d=>d['tax_species'], d=>d['desc']],        reduceFn:v=> v.length    });    console.log(newData);    debugger    drawCirclePack(newData);    // drawPack(nodeData);});function drawCirclePack(data) {    // Initialize root node    // let root = _.supergroup(data,['tax_species','desc','#node']).asRootVal('All species');    // root.addRecordsAsChildrenToLeafNodes();    // let hierarchy = d3.hierarchy(root);    // debugger    // pack(data);    // root.each(function(d) {    //     console.log(d.data)    // })    // hierarchy.sum(d=>d.length);    let root = pack(data);    // Draw nodes on svg    const node = svgPack.append("g")        .attr("pointer-events", "all")        .selectAll("g")        .data(root.descendants())        .enter().append("g")        .attr("transform", function(d) { return "translate(" + d.x/circleScale + "," + d.y/circleScale + ")"; })        .attr("class", function(d) { return "node" + (!d.children ? " node--leaf" : d.depth ? "" : " node--root"); })        .each(function(d) { d.node = this; })        .on("mouseover", hovered(true))        .on("mouseout", hovered(false));    node.append("circle")        .attr('id', d=>'node-'+ d.data[0])        .attr("r", d => d.r/circleScale)        .attr("stroke", d => d.children ? "#bbb" : "none")        .attr("fill", d => d.children ? "none" : "#ddd");    const leaf = node.filter(d => !d.children);    leaf.append("clipPath")        .attr("id", d => 'clip-' + d.data[0])        .append("use")        .attr("xlink:href", d => '#node-' + d.data[0]);    // leaf.append("text")    //     .attr("clip-path", d => 'url(#clip-)' + d.data[0])    //     .selectAll("tspan")    //     .data(d => d.data[0].split(/(?=[A-Z][^A-Z])/g))    //     .join("tspan")    //     .attr("x", 0)    //     .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.8}em`)    //     .text(d => d);    node.append("title")        .text(d => `${d.ancestors().map(d => d.data[0]).reverse().join("/")}${d.value.toLocaleString()}`);}function hovered(hover) {    return function(d) {        d3.selectAll(d.ancestors().map(function(d) { return d.node; })).classed("node--hover", hover);    };}// function to make data nested for hierarchical layoutfunction makeHierarchy(config) {    const defaultConfig = {        childrenAccessorFn: ([key, value]) => value.size && Array.from(value),        sumFn: ([key, value]) => value,        sortFn: (a, b) => b.value - a.value,    };    const { data,        reduceFn,        groupByFns,        childrenAccessorFn,        sumFn,        sortFn    } = { ...defaultConfig, ...config };    const rollupData = d3.rollup(data, reduceFn, ...groupByFns);    const groupData = d3.group(data,...groupByFns);    const hierarchyData = d3.hierarchy([null,rollupData], childrenAccessorFn)    // const hierarchyData = d3.hierarchy([null,groupData], childrenAccessorFn)        .sum(sumFn)        .sort(sortFn);    return hierarchyData;}