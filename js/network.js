let paths = ['data/t.tsv','test.tsv'];const width = 2000,      height = 2000;const format = d3.format(',d');const pack = d3.pack()    .size([width,height])    .padding(1);Promise.all(paths.map(path=>d3.tsv(path))).then(files=>{    let nodeData = files[0];    let linkData = files[1];    // let nest = _.supergroup(nodeData,['tax_species','desc','#node']).d3NestEntries();    // console.log(nest);    // let groupData = d3.group(nodeData,d=>d['tax_species'], d=>d['desc'],d=>d['#node']);    // // let nodes = nodeData.map(d=>d['#node']);    // console.log(groupData);    let links = linkData.map(d=>d);    let newData = makeHierarchy({        data:nodeData,        groupByFns:[d=>d['tax_species'], d=>d['desc'], d=>d['#node']],        reduceFn:v=>v.length    });    drawCirclePack(newData);});function drawCirclePack(data) {    let root = pack(data);    pack(data);    let svgPack = d3.select('#chart')        .append('svg')        .attr('width', width)        .attr('height', height);    const node = svgPack.append("g")        .attr("pointer-events", "all")        .selectAll("g")        .data(root.descendants())        .enter().append("g")        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })        .attr("class", function(d) { return "node" + (!d.children ? " node--leaf" : d.depth ? "" : " node--root"); })        .each(function(d) { d.node = this; })        .on("mouseover", hovered(true))        .on("mouseout", hovered(false));    node.append("circle")        .attr('id', d=>'node-'+ d.data[0])        .attr("r", d => d.r)        .attr("stroke", d => d.children ? "#bbb" : "none")        .attr("fill", d => d.children ? "none" : "#ddd");    const leaf = node.filter(d => !d.children);debugger    leaf.append("clipPath")        .attr("id", d => 'clip-' + d.data[0])        .append("use")        .attr("xlink:href", d => '#node-' + d.data[0]);    leaf.append("text")        .attr("clip-path", d => 'url(#clip-)' + d.data[0])        .selectAll("tspan")        .data(d => d.data[0].split(/(?=[A-Z][^A-Z])/g))        .join("tspan")        .attr("x", 0)        .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.8}em`)        .text(d => d);    node.append("title")        .text(d => `${d.ancestors().map(d => d.data[0]).reverse().join("/")}${d.value.toLocaleString()}`);//     svgPack.append("g")//         // .attr("fill", "#ccc")//         .selectAll("circle")//         .data(root.leaves())//         .join("circle")//         .attr("transform", d => `translate(${d.x},${d.y})`)//         .attr("r", d => d.r)//         .append("title")//         .text(d => `${d.ancestors().map(d => d.data[0]).reverse().join("/")}\n${format(d.value)}`);// debugger//     svgPack.append("g")//         .attr("pointer-events", "none")//         .attr("text-anchor", "middle")//         .selectAll("text")//         .data(root.leaves().filter(d => d.r > 0.1))//         .join("text")//         .attr("transform", d => `translate(${d.x},${d.y}) scale(${d.r / 30})`)//         .selectAll("tspan")//         .data(d => (d.data[0] + "").split(/\s+/g))//         .join("tspan")//         .attr("x", 0)//         .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.8}em`)//         .text(d => d);}function hovered(hover) {    return function(d) {        d3.selectAll(d.ancestors().map(function(d) { return d.node; })).classed("node--hover", hover);    };}// function to make data nested for hierarchical layoutfunction makeHierarchy(config) {    const defaultConfig = {        childrenAccessorFn: ([key, value]) => value.size && Array.from(value),        sumFn: ([key, value]) => value,        sortFn: (a, b) => b.value - a.value,    };    const { data,        reduceFn,        groupByFns,        childrenAccessorFn,        sumFn,        sortFn    } = { ...defaultConfig, ...config };    const rollupData = d3.rollup(data, reduceFn, ...groupByFns);    const hierarchyData = d3.hierarchy([null, rollupData], childrenAccessorFn)        .sum(sumFn)        .sort(sortFn);    return hierarchyData;}const innerRadius = 40;const outerRadius = 240;const angle = d3.scalePoint().domain(d3.range(20)).range([0, 2 * Math.PI]),    radius = d3.scaleLinear().range([innerRadius, outerRadius]);    // color = d3.scaleOrdinal(d3.schemeCategory10).domain(d3.range(20));function drawLayout(data,links){    window.root =_.supergroup(data,['tax_species','desc']).asRootVal('All species');    root.addRecordsAsChildrenToLeafNodes();    let nodes = root.descendants();    let treeLayout = d3.tree().size([width,height]);    treeLayout(root);    let svgTree = d3.select("#hiveChart").append("svg")        .attr("width", width)        .attr("height", height)        .append("g")        .attr("transform", "translate(" + width + "," + height + ")");    // nodes    svgTree.selectAll('circle.node')        .data(nodes)        .enter()        .append('circle')        .classed('node',true)        .attr('cx',d=>d.x)        .attr('cy',d=>d.y)        .attr('r',3);    // links    svgTree.selectAll('line.link')        .data(links)        .enter()        .append('line')        .classed('link',true)        .attr('x1', function(d) {return d.source.x;})        .attr('y1', function(d) {return d.source.y;})        .attr('x2', function(d) {return d.target.x;})        .attr('y2', function(d) {return d.target.y;});}function drawHive(nodes,links){    // var nodes = [    //     {x: 0, y: .1},    //     {x: 0, y: .9},    //     {x: 1, y: .2},    //     {x: 1, y: .3},    //     {x: 2, y: .1},    //     {x: 2, y: .8}    // ];    //    // var links = [    //     {source: nodes[0], target: nodes[2]},    //     {source: nodes[1], target: nodes[3]},    //     {source: nodes[2], target: nodes[4]},    //     {source: nodes[2], target: nodes[5]},    //     {source: nodes[3], target: nodes[5]},    //     {source: nodes[4], target: nodes[0]},    //     {source: nodes[5], target: nodes[1]}    // ];    let svgHive = d3.select("#hiveChart").append("svg")        .attr("width", width)        .attr("height", height)        .append("g")        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");    svgHive.selectAll(".axis")        .data(d3.range(3))        .enter().append("line")        .attr("class", "axis")        .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"; })        .attr("x1", radius.range()[0])        .attr("x2", radius.range()[1]);    svgHive.selectAll(".link")        .data(links)        .enter().append("path")        .attr("class", "link")        .attr("d", d3.hive.link()            .angle(function(d,i) { return angle(i); })            .radius(function(d,i) { return radius(i); }))        .style("stroke", function(d) { return color(d.source); });    svgHive.selectAll(".node")        .data(nodes)        .enter().append("circle")        .attr("class", "node")        .attr("transform", function(d,i) { return "rotate(" + degrees(angle(i)) + ")"; })        .attr("cx", function(d,i) { return radius(i/145832); })        .attr("r", 3)        .style("fill", function(d) { return d.color; });    function degrees(radians) {        return radians / Math.PI * 180 - 90;    }}